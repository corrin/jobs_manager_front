# Schema and Type Management

## ğŸš¨ ABSOLUTE RULE: NO LOCAL SCHEMAS FOR API DATA ğŸš¨

### Unique Source of Truth: `src/api/generated/api.ts`

**ALL types and schemas related to API data MUST come ONLY from the autogenerated file [`src/api/generated/api.ts`].**

This file is generated by Zodios based on the backend's DRF-Spectacular OpenAPI schema. It is the ONLY source of truth for API types and schemas in the frontend. Never create or maintain parallel types, interfaces, or schemas for API data anywhere else in the codebase.

---

### Total Prohibition of Local Schemas

**NEVER create local TypeScript interfaces, types, or schemas that duplicate API functionality.**

---

### ğŸš¨ DEFINITIVE TEST: DATABASE DATA PROHIBITION ğŸš¨

**If this data is stored in the database, it is FORBIDDEN to model it in the frontend.**

This is the absolute, foolproof test to determine if a type should be created locally:

- **Database data** (jobs, staff, purchase orders, deliveries, timesheets, etc.) â†’ âŒ FORBIDDEN
- **Form data for database entities** (contact forms, job, staff, etc.) â†’ âŒ FORBIDDEN
- **API request/response types** (create requests, update requests, API responses) â†’ âŒ FORBIDDEN
- **Pure UI structures ONLY** (dropdown options, tab names, filter structures, search forms) â†’ âœ… ALLOWED

### Clarification: Form Data for Database Entities IS DATABASE DATA

If a form creates, updates, or represents data that will be stored in the database, it is DATABASE DATA and must use backend schemas. The only allowed frontend forms are pure UI constructs like search filters or display preferences that are never persisted.

---

### ğŸš¨ WHEN IN DOUBT - DO NOT TOUCH THE CODE ğŸš¨

**If there is ANY ambiguity about whether a type represents database data, DO NOT WRITE ANY CODE. DO NOT EDIT ANYTHING. STOP AND LEARN. NEVER TRY TO WORK AROUND THIS RESTRICTION.**

#### Prohibited Actions When in Doubt

- âŒ Create frontend types "just in case"
- âŒ Make assumptions about what the data represents
- âŒ Use words like "probably", "seems like"
- âŒ Modify working code based on assumptions

#### Correct Approach When in Doubt

- âœ… LEAVE THE CODE UNTOUCHED
- âœ… Document as Category C (missing backend schema)
- âœ… Only fix types when 100% certain they are pure UI constructs

---

### ğŸš¨ NEVER COMMENT OUT OR DISABLE BROKEN IMPORTS ğŸš¨

**DO NOT create temporary workarounds, placeholder types, or disable imports to "unblock" builds**

**If an import is broken due to missing backend schemas, LEAVE IT BROKEN and document the requirement**

**The build MUST fail until proper schemas exist - this maintains architectural integrity**

#### Prohibited Actions with Broken Imports

- âŒ Comment out imports
- âŒ Create placeholder types `any`
- âŒ Create temporary type definitions
- âŒ Use `// @ts-ignore` or similar suppressions
- âŒ "Unblock" builds with workarounds

#### Correct Approach

- âœ… Document missing schema requirement for the backend team
- âœ… Leave the import broken to maintain pressure for proper correction
- âœ… Focus on files that can be legitimately fixed

---

### Schema Generation and Update

```bash
# Update backend schemas
npm run update-schema

# Generate API types (this will update src/api/generated/api.ts)
npm run gen:api
```

---

### Backend Coordination

**If the generated schema is wrong:** Coordinate with the backend to add proper `@extend_schema` or `@extend_schema_field` annotations, then regenerate with `npm run update-schema`.

---

### Related references

- See: [01-architectural-separation.md](./01-architectural-separation.md)
- See: [05-api-integration.md](./05-api-integration.md)
- See: [13-backend-coordination.md](./13-backend-coordination.md)
